<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RC4 (Rivest Cipher 4)</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='rc4_style.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="{{ url_for('static', filename='rc4_script.js') }}" defer></script>
</head>

<body>
    <div class="container">
        <header>
            <a href="/" class="home-btn"><i class="fas fa-arrow-left"></i> Menu</a>
            <h1>RC4 (Rivest Cipher 4)</h1>
            <p>Il Re dei Cifrari a Flusso (e la sua caduta)</p>
        </header>

        <!-- 1. CARTA D'IDENTIT√Ä -->
        <section class="section">
            <div class="card identity-card">
                <h2><i class="fas fa-id-card"></i> 1. La Carta d'Identit√†</h2>
                <ul class="identity-list">
                    <li><strong>Tipo:</strong> Stream Cipher (Cifrario a Flusso).</li>
                    <li><strong>Autore:</strong> Ron Rivest (lo stesso della "R" di RSA).</li>
                    <li><strong>Caratteristica:</strong> Simmetrico.</li>
                    <li><strong class="pro">Punto di Forza:</strong> Velocissimo in software (usa solo somme e scambi di
                        byte).</li>
                    <li><strong class="con">Punto Debole:</strong> Bias statistico nei primi byte generati (non
                        veramente casuali).</li>
                </ul>
            </div>
        </section>

        <!-- 2. STRUTTURA INTERNA -->
        <section class="section">
            <div class="card structure-card">
                <h2><i class="fas fa-microchip"></i> 2. La Struttura Interna: Il Vettore di Stato (S)</h2>
                <p>RC4 non usa matrici complesse o polinomi. Tutto si basa su un unico vettore chiamato <strong>S
                        (State)</strong>.</p>
                <div class="state-visual">
                    <div class="state-bar">
                        <span class="byte">S[0]</span>
                        <span class="byte">S[1]</span>
                        <span class="byte">...</span>
                        <span class="byte">S[255]</span>
                    </div>
                </div>
                <ul class="structure-details">
                    <li><strong>Dimensione:</strong> 256 byte (array da 0 a 255).</li>
                    <li><strong>Contenuto:</strong> Una <strong>permutazione</strong> di tutti i numeri da 0 a 255.
                        (All'inizio ordinati, poi mescolati. Niente duplicati).</li>
                    <li><strong>Variabili di supporto:</strong> Due indici, <code>i</code> e <code>j</code> (entrambi
                        partono da 0).</li>
                </ul>
            </div>
        </section>

        <!-- DEMO INTERATTIVA (MINI-RC4) -->
        <section class="section">
            <div class="card demo-card">
                <h2><i class="fas fa-gamepad"></i> Demo Interattiva: Mini-RC4 (N=8)</h2>
                <p>RC4 reale usa 256 numeri. Qui usiamo solo <strong>8 numeri</strong> (0-7) per capire il meccanismo di
                    mescolamento.</p>

                <div class="control-panel">
                    <label>Chiave (numeri separati da spazi): <input type="text" id="keyInput" value="1 2 3"></label>
                    <button id="initBtn" class="action-btn">üîÑ Reset / Carica Chiave</button>
                </div>

                <div class="visual-area">
                    <div class="pointers-legend">
                        <span class="legend-i">i (Indice Sequenziale)</span>
                        <span class="legend-j">j (Indice "Saltellante")</span>
                    </div>
                    <div id="rc4-state" class="rc4-grid">
                        <!-- Generated by JS -->
                    </div>
                </div>

                <div class="controls-row">
                    <div class="col">
                        <h4>Fase 1: KSA (Mescolamento)</h4>
                        <button id="ksaStepBtn" class="step-btn">Prossimo Step KSA</button>
                        <button id="runKsaBtn" class="step-btn">Completa KSA</button>
                    </div>
                    <div class="col">
                        <h4>Fase 2: PRGA (Generazione)</h4>
                        <button id="prgaByteBtn" class="step-btn" disabled>Genera Byte</button>
                    </div>
                </div>

                <div id="rc4-log" class="log-box">Log Operazioni...</div>

                <div class="output-area">
                    <strong>Keystream Output:</strong>
                    <div id="rc4-output"></div>
                </div>
            </div>
        </section>

        <div class="algorithm-split">
            <!-- 3. KSA -->
            <section class="section half-width">
                <div class="card ksa-card">
                    <h3><i class="fas fa-random"></i> 3. KSA (Key Scheduling Algorithm)</h3>
                    <p class="subtitle">"Il Mescolamento Iniziale"</p>
                    <p>Carichiamo la chiave mescolando il vettore S. √à come mescolare un mazzo di carte usando una
                        password.</p>

                    <div class="code-block">
                        <pre><code>// 1. Inizializzazione (Ordinata)
for i = 0 to 255:
    S[i] = i;

// 2. Mescolamento con Chiave K
j = 0;
for i = 0 to 255:
    // j dipende da se stesso, S[i] e la Chiave
    j = (j + S[i] + K[i % key_len]) % 256;

    // SCAMBIO!
    Swap(S[i], S[j]);</code></pre>
                    </div>
                    <p class="note">Ogni elemento viene scambiato almeno una volta. Alla fine S sembra casuale, ma √®
                        determinato dalla chiave.</p>
                </div>
            </section>

            <!-- 4. PRGA -->
            <section class="section half-width">
                <div class="card prga-card">
                    <h3><i class="fas fa-bolt"></i> 4. PRGA (Pseudo-Random Generation)</h3>
                    <p class="subtitle">"La Generazione del Flusso"</p>
                    <p>La chiave K non serve pi√π! Usiamo S mescolato per sputare fuori byte "casuali" (Keystream)
                        all'infinito.</p>

                    <div class="code-block">
                        <pre><code>i = 0; j = 0;

while (serve_byte):
    i = (i + 1) % 256;      // Avanza i
    j = (j + S[i]) % 256;   // Aggiorna j

    Swap(S[i], S[j]);       // Rimescola S!

    t = (S[i] + S[j]) % 256;
    K_out = S[t];           // Pesca byte

    // CIFRATURA (XOR)
    Cifrato = Messaggio ^ K_out;</code></pre>
                    </div>
                </div>
            </section>
        </div>

        <!-- 5. DEBOLEZZA WEP -->
        <section class="section">
            <div class="card wep-card">
                <h2><i class="fas fa-skull-crossbones"></i> 5. Il Dettaglio "Killer": Il Disastro WEP</h2>
                <div class="wep-content">
                    <div class="wep-text">
                        <p>Il caso pi√π famoso √® quello del vecchio Wi-Fi <strong>WEP</strong>.</p>

                        <div class="alert-box">
                            <strong>Il Problema (Stream Cipher 101):</strong><br>
                            Se cifri due messaggi diversi con lo <strong>STESSO Keystream</strong>, un attaccante fa lo
                            XOR dei cifrati e ottiene lo XOR dei messaggi, cancellando la chiave.
                            <div class="math-center">$$ C_1 \oplus C_2 = (M_1 \oplus K) \oplus (M_2 \oplus K) = M_1
                                \oplus M_2 $$</div>
                        </div>

                        <h3>L'Errore del WEP:</h3>
                        <ul>
                            <li>Usava <strong>IV (24 bit) + Password</strong> come chiave.</li>
                            <li>L'IV era troppo corto ‚Üí Si ripeteva dopo poche ore.</li>
                            <li><strong>Risultato:</strong> Stessa Password + Stesso IV = <strong>Stesso
                                    Keystream</strong>.</li>
                            <li>L'attaccante raccoglieva pacchetti con stesso IV e decifrava tutto.</li>
                        </ul>
                    </div>
                    <div class="wep-stat">
                        <h3>Bias Statistico</h3>
                        <p>I primi byte generati non sono del tutto casuali (correlati alla chiave).</p>
                        <p><strong>Soluzione (RC4-Drop):</strong> Scartare i primi 3072 byte generati. WEP non lo
                            faceva!</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- SINTESI TABLE -->
        <section class="section">
            <div class="card comparison-card">
                <h2><i class="fas fa-table"></i> Sintesi Visuale</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Fase</th>
                            <th>Variabili</th>
                            <th>Uso Chiave</th>
                            <th>Cosa succede al vettore S?</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>KSA</strong> (Setup)</td>
                            <td><code>i</code> (0..255)</td>
                            <td>‚úÖ Usa la CHIAVE per calcolare gli scambi</td>
                            <td>Viene mescolato per la prima volta.</td>
                        </tr>
                        <tr>
                            <td><strong>PRGA</strong> (Run)</td>
                            <td><code>i, j</code> (0..255)</td>
                            <td>‚ùå NON usa pi√π la chiave (usa solo S)</td>
                            <td>Continua a rimescolarsi a ogni byte generato.</td>
                        </tr>
                    </tbody>
                </table>
                <div class="summary-box">
                    <strong>Conclusione Esame:</strong> RC4 √® teoricamente robusto se si scartano i primi byte e non si
                    riusa mai la chiave (nonce). Ma a causa dei bias e del passato (WEP), oggi si usano
                    <strong>ChaCha20</strong> o <strong>AES-CTR</strong>.
                </div>
            </div>
        </section>

        <div style="text-align: center; margin-top: 50px; margin-bottom: 20px;">
            <a href="/" style="text-decoration: none;">
                <button
                    style="padding: 10px 20px; font-size: 1em; background: #30363d; color: #fff; border: 1px solid #8b949e; border-radius: 6px; cursor: pointer;">
                    <i class="fas fa-arrow-left"></i> Torna al Menu
                </button>
            </a>
        </div>
    </div>
</body>

</html>